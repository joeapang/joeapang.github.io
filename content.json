{"meta":{"title":"IMan","subtitle":"Life isn't so hard that we think!","description":null,"author":"Joea","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2016-05-18T08:09:54.000Z","updated":"2016-05-19T04:45:45.447Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","keywords":null,"text":"","raw":null,"content":null}],"posts":[{"title":"Java核心技术再理解理解：Java中类的加载原理","slug":"Java核心技术再理解理解：Java中类的加载原理","date":"2016-05-19T06:06:09.000Z","updated":"2016-05-19T06:38:09.681Z","comments":true,"path":"2016/05/19/Java核心技术再理解理解：Java中类的加载原理/","link":"","permalink":"http://yoursite.com/2016/05/19/Java核心技术再理解理解：Java中类的加载原理/","excerpt":"","keywords":null,"text":"虽然每天都用Java，现在尝试做一些项目也是用的Java，但是总感觉对这门语言学习的不够深入，对Java的认识也只是停留在别人博客中所说的，没有自己独特的理解。所以最近又把《Java核心技术》又重新的读了一遍。感觉对Java的认识还是比较欠缺。感觉学会一门语言并不是说会用就可以了，真正的理解这门语言，编程能力才会有质的提升。 下面我们就先从Java中最基本的类开始，探讨一下我们写的程序中的类是何时被初始化，又是何时被加载的。 ##类的加载 首先我们要清楚类的初始化和类的加载是两个不同的概念。类的加载是由类的加载器完成的，比如ClassLoader就是一个用Java写的一个加载器。所谓的加载就是当程序员在命令行中执行java HelloWord命令时，JVM会将HelloWord.java加载到内存中，然后编译成HelloWord.class文件的过程。 ##类的初始化类的初始化是发生在类加载完成后，这时类会先把静态属性初始化（Java中的初始化顺序是（静态变量、静态初始化块）&gt;（变量、初始化块）&gt;构造器）。类一般会在一下情况下发生初始化： 通过new关键字创建实例 该类的静态方法被调用 使用类的非常量静态字段（static修饰的变量，语句块。被final修饰的静态字段为变异字段，不会触发类的初始化） 通过Class.forName()反射创建实例 初始化该类的某个子类 当包含main()方法的类启动时 ##类的初始化步骤 类的初始化步骤一般分为3步： 如果一个类存在父类的话，并且其父类还没有被初始化，则优先初始化其父类 如果该类存在一个初始化方法，则执行该方法 静态域的初始化在非静态域之前（静态域的初始化在类的额静态初始化期间，非静态域的初始化在该类的实例穿件期间） ##代码 好的，下面我们通过一段简单的代码来体会一下Java中类的初始化过程。 定义父类： 12345678910111213141516171819package org.joea.classinit;public class SuperClass &#123; int a; static int b; static int c = 1; static &#123; b = 2; c = 3; System.out.println(\"SuperClass:static block has been initialized!\"); &#125; public void print() &#123; System.out.println(\"SuperClass:a=\" + a + \";b=\" + b + \";c=\" + c); &#125;&#125; 定义子类： 12345678910111213141516package org.joea.classinit;public class SubClass extends SuperClass&#123; int x; static int y=4; static &#123; y=5; System.out.println(\"SubClass:static block has been initialized! \"); &#125; public void print()&#123; super.print(); System.out.println(\"SubClass:a=\" + a + \";b=\" + b ); &#125;&#125; 测试类： 1234567891011121314package org.joea.classinit;public class Test &#123; static int temp; static&#123; temp=10; System.out.println(\"Test:static block has been initialized!\"); &#125; public static void main(String[] args)&#123; new SubClass().print(); &#125;&#125; 我们来看一下输出的结果： 12345Test:static block has been initialized!SuperClass:static block has been initialized!SubClass:static block has been initialized! SuperClass:a=0;b=2;c=3SubClass:a=0;b=2 从上面的输出结果我们可以看出，还有main函数的类优先初始化；超类的初始化优先于子类；静态域的初始化优先于非静态域；以上。","raw":null,"content":null,"categories":[{"name":"博客","slug":"博客","permalink":"http://yoursite.com/categories/博客/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]}]}